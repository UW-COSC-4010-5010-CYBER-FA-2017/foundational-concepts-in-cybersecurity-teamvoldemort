# Abstraction
Modeling a problem in such a way that necessary data is available to perform a task and extra information isn't just lying around waiting to be used in an attack.
# Simplicity
Designing software to be simple and focused rather than making complicated programs that are hard to work with. This ensures reliability and increases security.
# Domain Separation
Keeping distinct entities separate from one another. Not allowing a free-for-all on resources or materials.
# Modularization
Creating programs with interchangeable parts based on functionality. Each part solves a part of the problem while interfacing with the other parts seamlessly. 
# Information Hiding
Keeping unnecessary information hidden so that it can't be used in an attack. Giving functionality without being overly indulgent on how things are done behind the scenes.
# Least Privilege
Allowing the absolute minimum privileges necessary for a user to perform their agreed upon duties.
# Resource Encapsulation
Designing programs such that resources can only be used for their intended purposes. Restricting access to data such that resource use can be facilitated.
# Minimization
Keeping the code small and, in turn, keeping the security leaks small. For example, it is easier to make sure all of the doors are locked in a regular house than an entire mansion.
# Process Isolation
Keeping programs from interacting with each other so they can protect themselves from unexpected results of sharing resources.
# Layering
The process of applying multiple layers of security with each layer requiring a different form of authentication.
